---
phase: 01-foundation-core-data
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/liquidity/storage/questdb.py
  - src/liquidity/storage/schemas.py
  - src/liquidity/collectors/fred.py
  - docker-compose.yml
  - tests/integration/test_fred_collector.py
autonomous: true
---

<objective>
FRED API collector and QuestDB storage layer for Fed balance sheet data.

Purpose: Implement the core data pipeline - fetch Fed balance sheet series (WALCL, TGA, RRP) via OpenBB/FRED, store in QuestDB using ILP protocol, calculate Net Liquidity (Hayes formula). This proves the collector pattern works end-to-end.

Output: Working collector that fetches Fed data, stores in QuestDB, and Net Liquidity calculation verified against known values.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-core-data/01-RESEARCH.md
@.planning/phases/01-foundation-core-data/01-CONTEXT.md
@.planning/phases/01-foundation-core-data/01-01-SUMMARY.md

# FRED Series from Apps Script v3.4.1:
# WALCL = Fed Total Assets
# WTREGEN = Treasury General Account (TGA) - note: RESEARCH.md uses WDTGAL
# RRPONTSYD = Reverse Repo (RRP) - note: RESEARCH.md uses WLRRAL
# Use WLRRAL and WDTGAL as per OpenBB example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Docker Compose with QuestDB and Redis</name>
  <files>docker-compose.yml</files>
  <action>
    Create docker-compose.yml with services:

    1. QuestDB:
       - Image: questdb/questdb:latest
       - Ports: 9000 (web console), 9009 (ILP), 8812 (PostgreSQL wire)
       - Volume: questdb_data for persistence
       - Environment: QDB_TELEMETRY_ENABLED=false

    2. Redis:
       - Image: redis:7-alpine
       - Port: 6379
       - Volume: redis_data for persistence
       - Command: --appendonly yes (AOF persistence)

    3. Prometheus (optional, can add later):
       - Comment out for now, add when metrics needed

    Include named volumes for data persistence.
    Add healthchecks for both services.
  </action>
  <verify>docker compose up -d succeeds, curl localhost:9000 returns QuestDB web console</verify>
  <done>Docker services running, QuestDB accessible at localhost:9000</done>
</task>

<task type="auto">
  <name>Task 2: Implement QuestDB storage layer with ILP ingestion</name>
  <files>src/liquidity/storage/__init__.py, src/liquidity/storage/questdb.py, src/liquidity/storage/schemas.py</files>
  <action>
    Create storage package.

    Implement schemas.py with table definitions:
    - RAW_DATA table: timestamp, series_id (SYMBOL), source (SYMBOL), value (DOUBLE), unit (SYMBOL)
    - LIQUIDITY_INDEXES table: timestamp, index_name (SYMBOL), value (DOUBLE), regime (SYMBOL)
    - Both use PARTITION BY MONTH, WAL, DEDUP UPSERT KEYS

    Implement questdb.py with QuestDBStorage class:
    - __init__(host, port) with connection settings
    - ingest_dataframe(table, df, timestamp_col) using Sender with ILP
    - Convert DataFrame timestamps to datetime
    - Set symbols parameter for SYMBOL columns
    - create_tables() method to initialize schema via PGWire
    - get_latest(series_id) method for freshness checks
    - query(sql) method for ad-hoc queries via PGWire

    Follow QuestDB ILP pattern from RESEARCH.md code examples.
    Use context manager pattern for Sender (auto-flush on exit).
  </action>
  <verify>uv run python -c "from liquidity.storage.questdb import QuestDBStorage; s = QuestDBStorage()"</verify>
  <done>QuestDBStorage class importable, methods defined</done>
</task>

<task type="auto">
  <name>Task 3: Implement FRED collector for Fed balance sheet data</name>
  <files>src/liquidity/collectors/fred.py, tests/integration/test_fred_collector.py</files>
  <action>
    Implement fred.py with FredCollector extending BaseCollector:

    SERIES_MAP constant:
    - "fed_total_assets": "WALCL"
    - "rrp": "WLRRAL" (Reverse Repo)
    - "tga": "WDTGAL" (Treasury General Account)
    - "bank_reserves": "WRESBAL"
    - "sofr": "SOFR"

    collect() method:
    - Use OpenBB: obb.economy.fred_series(symbols, provider="fred")
    - Wrap in asyncio.to_thread() for async compatibility (OpenBB is sync)
    - Return DataFrame with date, series_id, value columns
    - Handle API errors with retry (inherited from BaseCollector)

    calculate_net_liquidity(df) static method:
    - Net Liquidity = WALCL - WLRRAL - WDTGAL (Hayes formula)
    - Return DataFrame with net_liquidity column

    Register collector with registry.

    Create integration test that:
    - Fetches last 30 days of data
    - Verifies all series present
    - Calculates Net Liquidity
    - Stores in QuestDB
    - Queries back to verify
  </action>
  <verify>uv run pytest tests/integration/test_fred_collector.py -v (with Docker running)</verify>
  <done>FRED collector fetches data, stores in QuestDB, Net Liquidity calculation works</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `docker compose up -d` starts QuestDB and Redis
- [ ] QuestDB web console accessible at http://localhost:9000
- [ ] `uv run python -c "from liquidity.collectors.fred import FredCollector"` works
- [ ] Integration test passes: fetches Fed data, stores in QuestDB
- [ ] Net Liquidity calculation produces reasonable values (~$6T range as of 2024-2025)
</verification>

<success_criteria>
- All tasks completed
- Docker services running (QuestDB, Redis)
- QuestDB storage layer working with ILP ingestion
- FRED collector fetching Fed balance sheet data
- Net Liquidity (Hayes formula) calculation implemented
- Data stored in QuestDB and queryable
- Integration test passing
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-data/01-02-SUMMARY.md`
</output>
